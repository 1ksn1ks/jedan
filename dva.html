<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HCS Insc</title>

    <script
      data-hcs-config
      data-hcs-cdn-url="https://kiloscribe.com/api/inscription-cdn/"
      data-hcs-network="mainnet"
      data-hcs-debug="true"
      data-hcs-retry-attempts="5"
      data-hcs-retry-backoff="500"
      data-hcs-show-loading-indicator="true"
      data-hcs-loading-callback-name="setLoadingIndicator"
    ></script>
    <link
      data-src="hcs://1/0.0.6762200"
      data-load-order="1"
      data-required="true"
      data-script-id="nes-css"
      type="css"
    />
    <script
      data-src="hcs://1/0.0.7337015"
      data-script-id="wallet-connect"
      data-load-order="2"
    ></script>
    <style>
body {
  margin: 0;
  background-color: #f4f4f9;
  font-family: Arial, Helvetica, sans-serif;
  color: #333;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  min-height: 100vh;
}

.container {
  background-color: #ffffff;
  max-width: 600px;
  width: 90%;
  padding: 30px;
  margin: 20px 0; /* Adds vertical spacing between containers */
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  border-radius: 8px;
  text-align: center;
  box-sizing: border-box;
}


.container h1 {
  font-size: 1.8rem;
  color: #333;
  margin-bottom: 15px;
  font-weight: bold;
}

.container p {
  font-size: 1rem;
  line-height: 1.6;
  color: #555;
  margin-bottom: 15px;
}

.container p:last-of-type {
  margin-bottom: 0;
}

.container p strong {
  color: #333;
}

.container p:nth-child(2),
.container p:nth-child(3),
.container p:nth-child(4) {
  font-weight: 500;
}

.container p:nth-child(2) {
  margin-top: 15px;
  color: #0055cc;
}

.container p:nth-child(4) {
  font-style: italic;
  color: #333;
}

.container p:nth-child(6) {
  color: #0057af;
  font-weight: bold;
  margin-top: 20px;
}

.container p:nth-child(7) {
  color: #333;
  font-weight: bold;
}

.container p:nth-child(8) {
  color: #333;
  font-weight: bold;
}


h1 {
  font-size: 1.5rem;
  text-align: center;
}

#game-ui {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

canvas {
  display: block;
  max-width: 100%;
  height: auto;
  margin: auto;
  border: 2px solid #fff;
}

#author-section, #wallet-section {
  position: relative;
  padding: 10px;
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  background-color: rgba(133, 132, 132, 0.7);
  border-radius: 5px;
  max-width: 100%;
  box-sizing: border-box;
  flex-wrap: wrap;
  justify-content: center;
}

#author-avatar {
  width: 40px;
  height: 40px;
  image-rendering: pixelated;
  border: 2px solid #f79d02;
  margin-right: 10px;
}

#author-name {
  font-size: 14px;
}

#wallet-section {
  text-align: center;
}

#wallet-section button {
  margin: 5px;
}

#account-id, #account-balance {
  font-size: 12px;
  margin-top: 5px;
}

#geojson-form {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#geojson-form label {
  font-size: 14px;
}

#geojson-form input, #geojson-form textarea, #geojson-form button {
  font-size: 14px;
  padding: 8px;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
}

#geojson-form button {
  cursor: pointer;
}

@media (min-width: 768px) {
  h1 {
    font-size: 2rem;
  }

  #author-section, #wallet-section {
    justify-content: flex-start;
  }

  #author-avatar {
    width: 50px;
    height: 50px;
  }

  #author-name, #wallet-section {
    font-size: 16px;
  }

  #geojson-form label {
    font-size: 16px;
  }

  #geojson-form input, #geojson-form textarea, #geojson-form button {
    font-size: 16px;
  }
}

    </style>

  </head>
  <body>
    <div class="container">
      <h1>Location-Based Info Inscribed on Hedera</h1>
      <p>Topic ID represents category</p>
      <p>ENTER title</p>
      <p>Link your web pages</p>
      <p>
        Share your thoughts about coordinates, post a video, photos, links...
      </p>
      <p>1. connect wallet</p>
      <p>2. choose topicID from category page (0.0.7390282) for testing</p>
      <p>3. submit msg</p>
    </div>
      <div id="author-section" class="nes-container is-rounded is-dark">
        <img
          id="author-avatar"
          data-src="hcs://1/0.0.6529019"
          alt="Kantorcodes Avatar"
        />
        <span id="author-name" class="nes-text is-primary"
          ><a href="https://x.com/kantorcodes">Stolen from Kantorcodes</a></span
        >
      </div>
      <div id="wallet-section" class="nes-container is-rounded is-dark">
        <button
          id="connect-wallet-btn"
          class="nes-btn is-primary connect-wallet-btn"
        >
          Connect Wallet
        </button>
        <button
          id="disconnect-wallet-btn"
          style="display: none"
          class="nes-btn is-warning disconnect-wallet-btn"
        >
          Disconnect
        </button>
        <div id="account-id"></div>
        <div id="account-balance"></div>
      </div>
    </div>
    <div class="container nes-container is-rounded is-dark">
      <form id="geojson-form">
        <label for="topic">Topic ID:</label><br />
        <input
          type="text"
          id="topic"
          placeholder="Enter topic ID"
        /><br /><br />

        <label for="title">Header letters (bolted):</label>
        <input type="text" id="title"/>

        <label for="url">Post your KILOSCRIBE.COM link page:</label>
        <input type="url" id="url" />

        <label for="text">What is on your mind?:</label>
        <textarea id="text" required></textarea>

        <label for="longitude">Set Longitude:</label>
        <input type="number" step="any" id="longitude" required />

        <label for="latitude">Set Latitude:</label>
        <input type="number" step="any" id="latitude" required />

        <button id="submit-msg">Inscribe Msg to Hedera</button>
        <button id="new-topic">newbTOPt</button>

        <label for="number">CREATED TOPICID:</label>
        <input type="text" id="newid"/>

      </form>
    </div>

    <script>
      const APP_METADATA = {
        name: "My PlanNet",
        description: "A Hashinals application using WalletConnect",
        url: "https://myptest.kiloscribe.com/",
        icons: ["https://tier.bot/api/inscription-cdn/0.0.4840719"],
      };

      const PROJECT_ID = "fdd65bec25e85908fecf7561fe42b41f";

      window.HCSReady = async function () {
        console.log("All resources loaded, initializing game");

        const sdk = window?.HashinalsWalletConnectSDK;

        async function updateAccountInfo(accountId, balance) {
          if (!accountId) {
            isLoggedIn = false;
            document.getElementById("connect-wallet-btn").style.display =
              "block";
            document.getElementById("disconnect-wallet-btn").style.display =
              "none";
            document.getElementById("account-id").textContent = ``;
            document.getElementById("account-balance").textContent = ``;
            return;
          }
          // example of getting user tokens, uncomment to try it out.
          // const tokens = await sdk.getAccountTokens(accountId);
          // console.log('tokens', tokens);

          isLoggedIn = true;
          document.getElementById(
            "account-id"
          ).textContent = `Connected: ${accountId}`;
          document.getElementById(
            "account-balance"
          ).textContent = `Balance: ${balance}`;
          document.getElementById("connect-wallet-btn").style.display = "none";
          document.getElementById("disconnect-wallet-btn").style.display =
            "block";
        }

        async function connectWallet() {
          try {
            const { balance, accountId } = await sdk.connectWallet(
              PROJECT_ID,
              APP_METADATA
            );
            console.log("account info is", accountId, balance);
            updateAccountInfo(accountId, balance);
          } catch (error) {
            console.error("Failed to connect wallet:", error);
          }
        }

        async function disconnectWallet() {
          try {
            await sdk.disconnectWallet(PROJECT_ID, APP_METADATA);
            updateAccountInfo(undefined);
          } catch (error) {
            console.error("Failed to connect wallet:", error);
          }
        }

        const initAccount = async () => {
          const accountResponse = await sdk.initAccount(
            PROJECT_ID,
            APP_METADATA
          );

          if (accountResponse && accountResponse.accountId) {
            updateAccountInfo(
              accountResponse.accountId,
              accountResponse.balance
            );
          }
        };

        initAccount();

  

        document
          .getElementById("connect-wallet-btn")
          .addEventListener("click", connectWallet);
        document
          .getElementById("disconnect-wallet-btn")
          .addEventListener("click", disconnectWallet);


// Event listeners
document.getElementById("submit-msg").addEventListener("click", submitmsg);
document.getElementById("new-topic").addEventListener("click", createTopicID);

async function createTopicID() { try {
    const createdTopicId = await window.HashinalsWalletConnectSDK.createTopic();
    console.log('New topic created:', createdTopicId);
    document.getElementById("newid").textContent = createdTopicId;
  } catch (error) {
    console.error('Error creating topic:', error);
    alert('There was an error creating the topic. Please check the console for details.');
  }
}

async function submitmsg() {
  const topicID = document.getElementById("topic").value || createdTopicId; // Use the input or createdTopicId
  const title = document.getElementById("title").value;
  const url = document.getElementById("url").value;
  const text = document.getElementById("text").value;
  const longitude = parseFloat(document.getElementById("longitude").value);
  const latitude = parseFloat(document.getElementById("latitude").value);

  if (isNaN(longitude) || isNaN(latitude)) {
    alert("Please enter valid coordinates.");
    return;
  }

  // Make sure `isLoggedIn` is accessible
  if (!isLoggedIn) {
    alert("You need to connect your wallet in order to submit a message.");
    return;
  }

  const description = `
    <strong>${title}</strong>
    <p><a href="${url}" target="_blank">${url}</a></p>
    <p>${text}</p>`;

  const newFeature = {
    type: "Feature",
    properties: {
      description: description,
      icon: "theatre",
    },
    geometry: {
      type: "Point",
      coordinates: [longitude, latitude],
    },
  };

  const geojsonOutput = {
    data: newFeature,
  };

  // Convert `geojsonOutput` to a JSON string before sending
  const message = JSON.stringify(geojsonOutput);

  try {
    const receipt = await window.HashinalsWalletConnectSDK.submitMessageToTopic(topicID, message);
    console.log('Message submitted successfully:', receipt);
  } catch (error) {
    console.error('Error submitting message:', error);
    alert('There was an error submitting the message. Please check the console for details.');
  }
}
      }

    </script>
    <script>
      !(function (t, e) {
        "object" == typeof exports && "undefined" != typeof module
          ? e(exports)
          : "function" == typeof define && define.amd
          ? define(["exports"], e)
          : e(
              ((t =
                "undefined" != typeof globalThis
                  ? globalThis
                  : t || self).HCSRecusionSDK = {})
            );
      })(this, function (t) {
        "use strict";
        class e {
          constructor() {
            (this.config = {
              cdnUrl: "https://kiloscribe.com/api/inscription-cdn/",
              network: "mainnet",
              retryAttempts: 3,
              retryBackoff: 300,
              debug: !1,
              showLoadingIndicator: !1,
              loadingCallbackName: null,
            }),
              (this.configMapping = {
                hcsCdnUrl: "cdnUrl",
                hcsNetwork: "network",
                hcsRetryAttempts: "retryAttempts",
                hcsRetryBackoff: "retryBackoff",
                hcsDebug: "debug",
                hcsShowLoadingIndicator: "showLoadingIndicator",
                hcsLoadingCallbackName: "loadingCallbackName",
              }),
              (this.LoadedScripts = {}),
              (this.LoadedWasm = {}),
              (this.LoadedImages = {}),
              (this.LoadedVideos = {}),
              (this.LoadedAudios = {}),
              (this.LoadedAudioUrls = {}),
              (this.LoadedGLBs = {}),
              (this.scriptLoadedEvent = new Event("HCSScriptLoaded")),
              (this.loadQueue = []),
              (this.isProcessingQueue = !1);
          }
          log(...t) {
            this.config.debug && console.log("[HCS SDK]", ...t);
          }
          error(...t) {
            console.error("[HCS SDK]", ...t);
          }
          loadConfigFromHTML() {
            const t = document.querySelector("script[data-hcs-config]");
            t &&
              Object.keys(this.configMapping).forEach((e) => {
                if (t.dataset[e]) {
                  const a = this.configMapping[e];
                  let i = t.dataset[e];
                  "true" === i && (i = !0),
                    "false" === i && (i = !1),
                    isNaN(Number(i)) || "" === i || (i = Number(i)),
                    (this.config[a] = i);
                }
              }),
              this.log("Loaded config:", this.config);
          }
          updateLoadingStatus(t, e) {
            if (
              "loaded" !== this.LoadedScripts[t] &&
              (this.config.showLoadingIndicator &&
                console.log("[HCS Loading] " + t + " : " + e),
              (this.LoadedScripts[t] = e),
              this.config.loadingCallbackName &&
                "function" == typeof window[this.config.loadingCallbackName])
            ) {
              const a = window[this.config.loadingCallbackName];
              "function" == typeof a && a(t, e);
            }
          }
          async fetchWithRetry(
            t,
            e = this.config.retryAttempts,
            a = this.config.retryBackoff
          ) {
            try {
              const e = await fetch(t);
              if (!e.ok) throw new Error("HTTP error! status: " + e.status);
              return e;
            } catch (i) {
              if (e > 0)
                return (
                  this.log(
                    "Retrying fetch for " + t + " Attempts left: " + (e - 1)
                  ),
                  await this.sleep(a),
                  this.fetchWithRetry(t, e - 1, 2 * a)
                );
              throw i;
            }
          }
          sleep(t) {
            return new Promise((e) => setTimeout(e, t));
          }
          isDuplicate(t) {
            return !!this.LoadedScripts[t];
          }
          async retrieveHCS1Data(
            t,
            e = this.config.cdnUrl,
            a = this.config.network
          ) {
            const i = await this.fetchWithRetry(e + t + "?network=" + a);
            return await i.blob();
          }
          async loadScript(t) {
            const e = t.getAttribute("data-src"),
              a = t.getAttribute("data-script-id"),
              i = null == e ? void 0 : e.split("/").pop(),
              o = t.getAttribute("type"),
              s = t.hasAttribute("data-required"),
              d = "module" === t.getAttribute("type");
            if (!this.isDuplicate(i || "")) {
              this.updateLoadingStatus(a, "loading");
              try {
                const e = t.getAttribute("data-cdn-url") || this.config.cdnUrl,
                  r = t.getAttribute("data-network") || this.config.network,
                  n = await this.retrieveHCS1Data(i, e, r);
                if ("wasm" === o) {
                  const e = await n.arrayBuffer(),
                    i = await WebAssembly.compile(e);
                  (this.LoadedWasm[a] = await WebAssembly.instantiate(i, {
                    env: {},
                    ...t.dataset,
                  })),
                    this.updateLoadingStatus(a, "loaded"),
                    window.dispatchEvent(this.scriptLoadedEvent),
                    this.log("Loaded wasm: " + a);
                } else {
                  const t = await n.text(),
                    e = document.createElement("script");
                  if (((e.textContent = t), d)) {
                    e.type = "module";
                    const a = new Blob([t], { type: "application/javascript" });
                    e.src = URL.createObjectURL(a);
                  }
                  document.body.appendChild(e),
                    this.updateLoadingStatus(a, "loaded"),
                    window.dispatchEvent(this.scriptLoadedEvent),
                    this.log("Loaded script: " + a),
                    (e.onerror = (t) => {
                      if (
                        (this.error("Failed to load " + o + ": " + a, t),
                        this.updateLoadingStatus(a, "failed"),
                        s)
                      )
                        throw t;
                    });
                }
              } catch (r) {
                if (
                  (this.error("Failed to load " + o + ": " + a, r),
                  this.updateLoadingStatus(a, "failed"),
                  s)
                )
                  throw r;
              }
            }
          }
          async loadStylesheet(t) {
            const e = t.getAttribute("data-src"),
              a = t.getAttribute("data-script-id"),
              i = null == e ? void 0 : e.split("/").pop(),
              o = t.hasAttribute("data-required");
            if (!this.isDuplicate(i || "")) {
              this.updateLoadingStatus(a, "loading");
              try {
                const e = t.getAttribute("data-cdn-url") || this.config.cdnUrl,
                  o = t.getAttribute("data-network") || this.config.network,
                  s = await this.retrieveHCS1Data(i, e, o),
                  d = await s.text(),
                  r = document.createElement("style");
                (r.textContent = d),
                  document.head.appendChild(r),
                  this.updateLoadingStatus(a, "loaded"),
                  window.dispatchEvent(this.scriptLoadedEvent),
                  this.log("Loaded and inlined stylesheet: " + a);
              } catch (s) {
                if (
                  (this.error("Failed to load stylesheet: " + a, s),
                  this.updateLoadingStatus(a, "failed"),
                  o)
                )
                  throw s;
              }
            }
          }
          async loadImage(t) {
            const e = t.getAttribute("data-src"),
              a = null == e ? void 0 : e.split("/").pop();
            this.log("Loading image: " + a),
              this.updateLoadingStatus("Image: " + a, "loaded");
            try {
              const e = t.getAttribute("data-cdn-url") || this.config.cdnUrl,
                i = t.getAttribute("data-network") || this.config.network,
                o = await this.retrieveHCS1Data(a, e, i),
                s = URL.createObjectURL(o);
              (t.src = s),
                (this.LoadedImages[a] = s),
                this.updateLoadingStatus("Image: " + a, "loaded"),
                this.log("Loaded image: " + a);
            } catch (i) {
              this.error("Failed to load image: " + a, i),
                this.updateLoadingStatus("Image: " + a, "failed");
            }
          }
          async loadMedia(t, e) {
            const a = t.getAttribute("data-src"),
              i = null == a ? void 0 : a.split("/").pop();
            this.log("Loading " + e + ": " + i),
              this.updateLoadingStatus(e + ": " + i, "loading");
            try {
              const a = t.getAttribute("data-cdn-url") || this.config.cdnUrl,
                o = t.getAttribute("data-network") || this.config.network,
                s = await this.retrieveHCS1Data(i, a, o),
                d = URL.createObjectURL(s);
              (t.src = d),
                "video" === e
                  ? (this.LoadedVideos[i] = d)
                  : (this.LoadedAudioUrls[i] = d),
                this.updateLoadingStatus(e + ": " + i, "loaded"),
                this.log("Loaded " + e + ": " + i);
            } catch (o) {
              this.error("Failed to load " + e + ": " + i, o),
                this.updateLoadingStatus(e + ": " + i, "failed");
            }
          }
          async loadGLB(t) {
            const e = t.getAttribute("data-src"),
              a = null == e ? void 0 : e.split("/").pop();
            this.log("Loading GLB: " + a),
              this.updateLoadingStatus("GLB: " + a, "loading");
            try {
              const e = t.getAttribute("data-cdn-url") || this.config.cdnUrl,
                i = t.getAttribute("data-network") || this.config.network,
                o = await this.retrieveHCS1Data(a, e, i),
                s = URL.createObjectURL(o);
              (t.src = s),
                (this.LoadedGLBs[a] = s),
                this.updateLoadingStatus("GLB: " + a, "loaded"),
                this.log("Loaded GLB: " + a);
            } catch (i) {
              this.error("Failed to load GLB: " + a, i),
                this.updateLoadingStatus("GLB: " + a, "failed");
            }
          }
          async loadResource(t, e, a) {
            return new Promise((i) => {
              this.loadQueue.push({
                element: t,
                type: e,
                order: a,
                resolve: i,
              }),
                this.processQueue();
            });
          }
          async processQueue() {
            if (!this.isProcessingQueue) {
              for (this.isProcessingQueue = !0; this.loadQueue.length > 0; ) {
                const e = this.loadQueue.shift();
                try {
                  "script" === e.type
                    ? await this.loadScript(e.element)
                    : "image" === e.type
                    ? await this.loadImage(e.element)
                    : "video" === e.type || "audio" === e.type
                    ? await this.loadMedia(e.element, e.type)
                    : "glb" === e.type
                    ? await this.loadGLB(e.element)
                    : "css" === e.type &&
                      (await this.loadStylesheet(e.element)),
                    e.resolve();
                } catch (t) {
                  if (
                    (this.error("Error processing queue item:", t),
                    "script" === e.type &&
                      e.element.hasAttribute("data-required"))
                  )
                    break;
                }
              }
              this.isProcessingQueue = !1;
            }
          }
          async init() {
            return (
              this.loadConfigFromHTML(),
              new Promise((t) => {
                const e = async () => {
                  const e = document.querySelectorAll(
                      'script[data-src^="hcs://"]'
                    ),
                    a = document.querySelectorAll('img[data-src^="hcs://"]'),
                    i = document.querySelectorAll('video[data-src^="hcs://"]'),
                    o = document.querySelectorAll('audio[data-src^="hcs://"]'),
                    s = document.querySelectorAll(
                      'model-viewer[data-src^="hcs://"]'
                    ),
                    d = document.querySelectorAll('link[data-src^="hcs://"]'),
                    r = [];
                  [
                    { elements: e, type: "script" },
                    { elements: a, type: "image" },
                    { elements: i, type: "video" },
                    { elements: o, type: "audio" },
                    { elements: s, type: "glb" },
                    { elements: d, type: "css" },
                  ].forEach(({ elements: t, type: e }) => {
                    t.forEach((t) => {
                      const a =
                        parseInt(t.getAttribute("data-load-order") || "") ||
                        1 / 0;
                      r.push(this.loadResource(t, e, a));
                    });
                  }),
                    await Promise.all(r);
                  const n = new MutationObserver((t) => {
                    t.forEach((t) => {
                      t.addedNodes.forEach((t) => {
                        if (t.nodeType === Node.ELEMENT_NODE) {
                          const e = t;
                          e.matches('script[data-src^="hcs://"]')
                            ? this.loadResource(e, "script", 1 / 0)
                            : e.matches('img[data-src^="hcs://"]')
                            ? this.loadResource(e, "image", 1 / 0)
                            : e.matches('video[data-src^="hcs://"]')
                            ? this.loadResource(e, "video", 1 / 0)
                            : e.matches('audio[data-src^="hcs://"]')
                            ? this.loadResource(e, "audio", 1 / 0)
                            : e.matches('model-viewer[data-src^="hcs://"]')
                            ? this.loadResource(e, "glb", 1 / 0)
                            : e.matches('link[data-src^="hcs://"]') &&
                              this.loadResource(e, "css", 1 / 0);
                        }
                      });
                    });
                  });
                  document.body
                    ? n.observe(document.body, { childList: !0, subtree: !0 })
                    : document.addEventListener("DOMContentLoaded", () => {
                        n.observe(document.body, {
                          childList: !0,
                          subtree: !0,
                        });
                      }),
                    t();
                };
                "loading" === document.readyState
                  ? document.addEventListener("DOMContentLoaded", e)
                  : e();
              })
            );
          }
          async preloadImage(t) {
            this.log("Loading image:" + t),
              this.updateLoadingStatus("image: " + t, "loading");
            const e = await this.retrieveHCS1Data(t),
              a = URL.createObjectURL(e);
            return (
              (this.LoadedImages[t] = a),
              this.updateLoadingStatus("image: " + t, "loaded"),
              a
            );
          }
          async preloadAudio(t) {
            const e = document.createElement("audio");
            e.setAttribute("data-topic-id", t),
              e.setAttribute("data-src", "hcs://1/" + t),
              document.body.appendChild(e),
              await this.loadMedia(e, "audio");
            const a = document.querySelector(
              'audio[data-topic-id="' + t + '"]'
            );
            return (
              a
                ? (this.LoadedAudioUrls[t] = a.src)
                : console.error("Failed to preload audio: " + t),
              this.LoadedAudioUrls[t]
            );
          }
          async playAudio(t, e = 1) {
            const a = this.LoadedAudioUrls[t];
            if (a) {
              const i = new Audio(a);
              (i.volume = e),
                (this.LoadedAudios[t] = i),
                i.play().catch((t) => {
                  console.error("Failed to play audio:", t);
                }),
                i.addEventListener("ended", () => {
                  i.remove(), delete this.LoadedAudios[t];
                });
            } else console.error("Audio not preloaded: " + t);
          }
          async pauseAudio(t) {
            var e, a;
            const i = document.querySelector(
              'audio[data-topic-id="' + t + '"]'
            );
            i
              ? (console.log("found element", i),
                i.pause(),
                null == (e = this.LoadedAudios[t]) || e.pause())
              : null == (a = this.LoadedAudios[t]) || a.pause();
          }
          async loadAndPlayAudio(t, e = !1, a = 1) {
            let i = document.querySelector('audio[data-topic-id="' + t + '"]');
            if (i) (i.volume = a), await i.play();
            else {
              const o = document.createElement("audio");
              (o.volume = a),
                e && o.setAttribute("autoplay", "autoplay"),
                o.setAttribute("data-topic-id", t),
                o.setAttribute("data-src", "hcs://1/" + t),
                document.body.appendChild(o),
                await this.loadMedia(o, "audio"),
                (i = document.querySelector(
                  'audio[data-topic-id="' + t + '"]'
                )),
                e || (await i.play());
            }
          }
        }
        (window.HCS = new e()),
          window.HCS.init().then(() => {
            console.log("All HCS resources loaded"),
              "function" == typeof window.HCSReady &&
                (console.log("Running HCSReady..."), window.HCSReady());
          });
        const a = window.HCS;
        (t.HCS = e),
          (t.default = a),
          (t.sleep = (t) => new Promise((e) => setTimeout(e, t))),
          Object.defineProperties(t, {
            __esModule: { value: !0 },
            [Symbol.toStringTag]: { value: "Module" },
          });
      });
    </script>
  </body>
</html>
